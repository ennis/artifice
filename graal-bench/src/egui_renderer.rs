//! egui integration
use crate::shader::create_shader_module;
use glam::{Mat4, Vec2, Vec4};
use graal::{
    ash::version::DeviceV1_0, vk, FragmentOutputInterface, ImageInfo, Norm,
    TypedBufferInfo, VertexInputInterfaceExt,
};
use inline_spirv::include_spirv;
use std::ptr;

static EGUI_SHADER_VERT: &[u32] = include_spirv!("shaders/egui.vert", vert);
static EGUI_SHADER_FRAG: &[u32] = include_spirv!("shaders/egui.frag", frag);

// issues:
// 1. DescriptorImageInfo for samplers
// 2. format of the render target can't be easily changed dynamically
// 3. lots of boilerplate for pipeline creation
// 4. passed target must have the correct image usage flags set
// 5. need to specify the correct usage flags for uniform buffers
// 6. need to copy/move the pipeline, pipeline layout and render pass before entering the command callback
// 7. create_framebuffer method, generated by DescriptorSetInterface, is not visible by autocompletion
// 8. registering accesses to resources manually is a PITA
// 8.1. unreferenced transient resources end up silently deleted before the pass starts
// 9. there needs to be something to simplify the creation of render passes and stuff
// 10. possible confusion between Context and CommandContext
// 11. implementing VertexData for a foreign type is sometimes necessary
// 12. unclear whether it's necessary to register an uniform buffer or not for synchronization
// 13. BufferData defines len() for references to arrays, which shadows the slice length => this is very sneaky and *must* be eliminated
// 14. color blend attachment must match the number of attachments, but they are not specified at the same location

// constraints:
// * don't add things to graal itself, it's already complicated enough as it is
//

// solutions:
// * anything related to descriptor management => bindless
// * pipelines: not much we can do, except maybe providing sensible defaults?
// * render pass: store alongside pipeline, create on-the-fly
// * need to specify the correct usage flags for uniform buffers => create shorthand functions, return a typed view
// * image views: create on-the-fly, made obsolete by bindless

// --- Vertices ------------------------------------------------------------------------------------
#[derive(Copy, Clone, Debug, graal::VertexData)]
#[repr(C)]
struct Vertex {
    a_pos: Vec2,
    a_tc: Vec2,
    a_srgba: [u8; 4],
}

// --- Uniforms ------------------------------------------------------------------------------------

/// Per-scene uniforms.
#[derive(Copy, Clone, Debug)]
#[repr(C)]
struct Globals {
    u_screen_size: Vec2,
}

// --- Shader interfaces ---------------------------------------------------------------------------
#[derive(graal::DescriptorSetInterface)]
#[repr(C)]
struct GlobalsInterface {
    #[layout(binding = 0, uniform_buffer, stages(vertex))]
    globals: graal::BufferDescriptor<Globals>,
    #[layout(binding = 1, sampled_image, stages(fragment))]
    image: vk::DescriptorImageInfo,
    #[layout(binding = 2, sampler, stages(fragment))]
    sampler: vk::DescriptorImageInfo,
}

#[derive(Copy, Clone, Debug, graal::VertexInputInterface)]
struct VertexInput {
    #[layout(binding = 0, location = 0, per_vertex)]
    vertices: graal::VertexBufferView<Vertex>,
}

pub struct EguiRenderer {
    pipeline: vk::Pipeline,
    pipeline_layout: vk::PipelineLayout,
    render_pass: vk::RenderPass,
    egui_texture: Option<ImageInfo>,
    egui_texture_version: Option<u64>,
    sampler: vk::Sampler,
    target_format: vk::Format,
}

impl EguiRenderer {
    /// Creates a new renderer for a specified target image format.
    pub fn new(context: &mut graal::Context, target_format: vk::Format) -> EguiRenderer {
        // --- shaders ---
        let vert = create_shader_module(context, EGUI_SHADER_VERT);
        let frag = create_shader_module(context, EGUI_SHADER_FRAG);

        let shader_stages = [
            vk::PipelineShaderStageCreateInfo {
                stage: vk::ShaderStageFlags::VERTEX,
                module: vert,
                p_name: b"main\0".as_ptr() as *const i8,
                ..Default::default()
            },
            vk::PipelineShaderStageCreateInfo {
                stage: vk::ShaderStageFlags::FRAGMENT,
                module: frag,
                p_name: b"main\0".as_ptr() as *const i8,
                ..Default::default()
            },
        ];

        // --- layout ---
        let mut set_layouts =
            [context.get_or_create_descriptor_set_layout_for_interface::<GlobalsInterface>()];

        let pipeline_layout_create_info = vk::PipelineLayoutCreateInfo {
            set_layout_count: set_layouts.len() as u32,
            p_set_layouts: set_layouts.as_ptr(),
            ..Default::default()
        };

        let pipeline_layout = unsafe {
            context
                .vulkan_device()
                .create_pipeline_layout(&pipeline_layout_create_info, None)
                .unwrap()
        };

        // --- render pass ---
        let render_pass = unsafe {
            let render_pass_attachments = &[vk::AttachmentDescription {
                flags: vk::AttachmentDescriptionFlags::MAY_ALIAS,
                format: target_format,
                samples: vk::SampleCountFlags::TYPE_1,
                load_op: vk::AttachmentLoadOp::DONT_CARE,
                store_op: vk::AttachmentStoreOp::STORE,
                stencil_load_op: vk::AttachmentLoadOp::DONT_CARE,
                stencil_store_op: vk::AttachmentStoreOp::DONT_CARE,
                initial_layout: vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL,
                final_layout: vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL,
            }];

            let color_attachments = &[vk::AttachmentReference {
                attachment: 0,
                layout: vk::ImageLayout::COLOR_ATTACHMENT_OPTIMAL,
            }];

            let subpasses = &[vk::SubpassDescription {
                flags: Default::default(),
                pipeline_bind_point: vk::PipelineBindPoint::GRAPHICS,
                input_attachment_count: 0,
                p_input_attachments: ptr::null(),
                color_attachment_count: color_attachments.len() as u32,
                p_color_attachments: color_attachments.as_ptr(),
                p_resolve_attachments: ptr::null(),
                p_depth_stencil_attachment: ptr::null(),
                preserve_attachment_count: 0,
                p_preserve_attachments: ptr::null(),
            }];

            // render pass
            let render_pass_create_info = vk::RenderPassCreateInfo {
                flags: Default::default(),
                attachment_count: render_pass_attachments.len() as u32,
                p_attachments: render_pass_attachments.as_ptr(),
                subpass_count: subpasses.len() as u32,
                p_subpasses: subpasses.as_ptr(),
                dependency_count: 0,
                p_dependencies: ptr::null(),
                ..Default::default()
            };

            context
                .vulkan_device()
                .create_render_pass(&render_pass_create_info, None)
                .unwrap()
        };

        // --- pipeline ---
        let input_assembly_state = vk::PipelineInputAssemblyStateCreateInfo {
            topology: vk::PrimitiveTopology::TRIANGLE_LIST,
            primitive_restart_enable: 0,
            ..Default::default()
        };

        let tessellation_state = vk::PipelineTessellationStateCreateInfo {
            patch_control_points: 0,
            ..Default::default()
        };

        let viewport_state = vk::PipelineViewportStateCreateInfo {
            viewport_count: 1,
            p_viewports: ptr::null(),
            scissor_count: 1,
            p_scissors: ptr::null(),
            ..Default::default()
        };

        let rasterization_state = vk::PipelineRasterizationStateCreateInfo {
            depth_clamp_enable: 0,
            rasterizer_discard_enable: 0,
            polygon_mode: vk::PolygonMode::FILL,
            cull_mode: vk::CullModeFlags::NONE,
            front_face: vk::FrontFace::CLOCKWISE,
            depth_bias_enable: vk::FALSE,
            depth_bias_constant_factor: 0.0,
            depth_bias_clamp: 0.0,
            depth_bias_slope_factor: 0.0,
            line_width: 1.0,
            ..Default::default()
        };

        let multisample_state = vk::PipelineMultisampleStateCreateInfo {
            rasterization_samples: vk::SampleCountFlags::TYPE_1,
            sample_shading_enable: 0,
            min_sample_shading: 0.0,
            p_sample_mask: ptr::null(),
            alpha_to_coverage_enable: vk::FALSE,
            alpha_to_one_enable: vk::FALSE,
            ..Default::default()
        };

        let depth_stencil_state = vk::PipelineDepthStencilStateCreateInfo {
            depth_test_enable: vk::TRUE,
            depth_write_enable: vk::TRUE,
            depth_compare_op: vk::CompareOp::LESS,
            depth_bounds_test_enable: vk::FALSE,
            stencil_test_enable: vk::FALSE,
            front: Default::default(),
            back: Default::default(),
            min_depth_bounds: 0.0,
            max_depth_bounds: 1.0,
            ..Default::default()
        };

        let no_blend = vk::PipelineColorBlendAttachmentState {
            blend_enable: vk::FALSE,
            color_write_mask: vk::ColorComponentFlags::R
                | vk::ColorComponentFlags::G
                | vk::ColorComponentFlags::B
                | vk::ColorComponentFlags::A,
            ..Default::default()
        };

        let color_blend_attachments = &[no_blend];

        let color_blend_state = vk::PipelineColorBlendStateCreateInfo {
            flags: Default::default(),
            logic_op_enable: 0,
            logic_op: Default::default(),
            attachment_count: color_blend_attachments.len() as u32,
            p_attachments: color_blend_attachments.as_ptr(),
            blend_constants: [0.0f32; 4],
            ..Default::default()
        };

        let dynamic_states = &[vk::DynamicState::VIEWPORT, vk::DynamicState::SCISSOR];

        let dynamic_state = vk::PipelineDynamicStateCreateInfo {
            flags: Default::default(),
            dynamic_state_count: dynamic_states.len() as u32,
            p_dynamic_states: dynamic_states.as_ptr(),
            ..Default::default()
        };

        let gpci = vk::GraphicsPipelineCreateInfo {
            flags: Default::default(),
            stage_count: shader_stages.len() as u32,
            p_stages: shader_stages.as_ptr(),
            p_vertex_input_state: &VertexInput::get_pipeline_vertex_input_state_create_info(),
            p_input_assembly_state: &input_assembly_state,
            p_tessellation_state: &tessellation_state,
            p_viewport_state: &viewport_state,
            p_rasterization_state: &rasterization_state,
            p_multisample_state: &multisample_state,
            p_depth_stencil_state: &depth_stencil_state,
            p_color_blend_state: &color_blend_state,
            p_dynamic_state: &dynamic_state,
            layout: pipeline_layout,
            render_pass,
            subpass: 0,
            base_pipeline_handle: Default::default(),
            base_pipeline_index: 0,
            ..Default::default()
        };

        let pipeline = unsafe {
            context
                .vulkan_device()
                .create_graphics_pipelines(vk::PipelineCache::null(), &[gpci], None)
                .unwrap()[0]
        };

        // --- sampler ---
        let sampler = unsafe {
            let sampler_create_info = vk::SamplerCreateInfo {
                mag_filter: vk::Filter::NEAREST,
                min_filter: vk::Filter::NEAREST,
                mipmap_mode: vk::SamplerMipmapMode::NEAREST,
                address_mode_u: vk::SamplerAddressMode::CLAMP_TO_EDGE,
                address_mode_v: vk::SamplerAddressMode::CLAMP_TO_EDGE,
                address_mode_w: vk::SamplerAddressMode::CLAMP_TO_EDGE,
                ..Default::default()
            };

            context
                .vulkan_device()
                .create_sampler(&sampler_create_info, None)
                .unwrap()
        };

        EguiRenderer {
            pipeline,
            pipeline_layout,
            render_pass,
            egui_texture: None,
            egui_texture_version: None,
            sampler,
            target_format,
        }
    }

    /*fn allocate_buffers(&self, batch: &graal::Batch, size: (u32, u32)) -> GBuffers {
        let color =
            create_transient_gbuffer_color_image(batch, vk::Format::R16G16B16A16_SFLOAT, size);
        let normal = create_transient_gbuffer_color_image(batch, vk::Format::R16G16_SFLOAT, size);
        let tangent = create_transient_gbuffer_color_image(batch, vk::Format::R16G16_SFLOAT, size);

        let depth = batch.create_transient_image(
            "depth_buffer",
            &graal::ResourceMemoryInfo::DEVICE_LOCAL,
            &graal::ImageResourceCreateInfo {
                image_type: vk::ImageType::TYPE_2D,
                usage: vk::ImageUsageFlags::DEPTH_STENCIL_ATTACHMENT
                    | vk::ImageUsageFlags::SAMPLED
                    | vk::ImageUsageFlags::STORAGE,
                format: vk::Format::D32_SFLOAT,
                extent: vk::Extent3D {
                    width: size.0,
                    height: size.1,
                    depth: 1,
                },
                mip_levels: 1,
                array_layers: 1,
                samples: 1,
                tiling: vk::ImageTiling::OPTIMAL,
            },
        );

        GBuffers {
            color,
            normal,
            tangent,
            depth,
        }
    }*/

    fn upload_texture(&mut self, frame: &graal::Frame, texture: &egui::Texture) {
        if Some(texture.version) == self.egui_texture_version {
            return;
        }

        let width = texture.width as u32;
        let height = texture.height as u32;

        let image = frame.context().create_image(
            "egui texture",
            &graal::ResourceMemoryInfo::DEVICE_LOCAL,
            &graal::ImageResourceCreateInfo {
                image_type: vk::ImageType::TYPE_2D,
                usage: vk::ImageUsageFlags::SAMPLED | vk::ImageUsageFlags::TRANSFER_DST,
                format: vk::Format::R8G8B8A8_SNORM,
                extent: vk::Extent3D {
                    width,
                    height,
                    depth: 1,
                },
                mip_levels: 1,
                array_layers: 1,
                samples: 1,
                tiling: Default::default(),
            },
            false,
        );

        let byte_size = width as usize * height as usize;

        // copy image data to staging buffer
        let mut staging_buffer = frame.upload_slice(
            vk::BufferUsageFlags::TRANSFER_SRC,
            texture.pixels.as_slice(),
            None,
        );

        // build the upload pass
        frame.add_graphics_pass("image upload", |pass| {
            pass.register_image_access(image.id, graal::AccessType::TransferWrite);
            pass.register_buffer_access(staging_buffer.id, graal::AccessType::TransferRead);

            pass.set_commands(move |context, command_buffer| unsafe {
                let device = context.vulkan_device();

                let regions = &[vk::BufferImageCopy {
                    buffer_offset: 0,
                    buffer_row_length: width,
                    buffer_image_height: height,
                    image_subresource: vk::ImageSubresourceLayers {
                        aspect_mask: vk::ImageAspectFlags::COLOR,
                        mip_level: 0,
                        base_array_layer: 0,
                        layer_count: 1,
                    },
                    image_offset: vk::Offset3D { x: 0, y: 0, z: 0 },
                    image_extent: vk::Extent3D {
                        width,
                        height,
                        depth: 1,
                    },
                }];

                device.cmd_copy_buffer_to_image(
                    command_buffer,
                    staging_buffer.handle,
                    image.handle,
                    vk::ImageLayout::TRANSFER_DST_OPTIMAL,
                    regions,
                );
            });
        });

        self.egui_texture_version = Some(texture.version);
        self.egui_texture = Some(image);
    }

    /// Renders the GUI to the specified target image.
    pub fn render(
        &mut self,
        frame: &graal::Frame,
        target: graal::ImageInfo,
        target_size: (u32, u32),
        clipped_meshes: Vec<egui::ClippedMesh>,
        egui_texture: &egui::Texture,
    ) {
        // --- update texture ---
        self.upload_texture(frame, egui_texture);

        // --- setup uniforms & descriptors ---
        let global_uniforms = frame.upload(
            vk::BufferUsageFlags::UNIFORM_BUFFER,
            &Globals {
                u_screen_size: Vec2::new(target_size.0 as f32, target_size.1 as f32),
            },
            None,
        );

        // --- upload mesh data ---
        struct Mesh {
            vbo: TypedBufferInfo<Vertex>,
            ibo: TypedBufferInfo<u32>,
            scissor: vk::Rect2D,
            index_count: u32,
        }

        let mut meshes = Vec::new();
        for mesh in clipped_meshes.iter() {
            let vbo: TypedBufferInfo<Vertex> = unsafe {
                frame
                    .upload_slice(
                        vk::BufferUsageFlags::VERTEX_BUFFER,
                        mesh.1.vertices.as_slice(),
                        None,
                    )
                    .byte_cast()
            };
            let ibo: TypedBufferInfo<u32> = frame.upload_slice(
                vk::BufferUsageFlags::INDEX_BUFFER,
                mesh.1.indices.as_slice(),
                None,
            );
            let scissor = vk::Rect2D {
                offset: vk::Offset2D {
                    x: mesh.0.min.x as i32,
                    y: mesh.0.min.y as i32,
                },
                extent: vk::Extent2D {
                    width: mesh.0.width() as u32,
                    height: mesh.0.height() as u32,
                },
            };

            meshes.push(Mesh {
                vbo,
                ibo,
                scissor,
                index_count: mesh.1.indices.len() as u32,
            });
        }

        // setup the pass
        frame.add_graphics_pass("egui", |pass| {
            let target_format = self.target_format;
            let pipeline = self.pipeline;
            let pipeline_layout = self.pipeline_layout;
            let render_pass = self.render_pass;
            let texture = self.egui_texture.unwrap();
            let sampler = self.sampler;

            pass.register_image_access(target.id, graal::AccessType::ColorAttachmentReadWrite);
            pass.register_image_access(texture.id, graal::AccessType::FragmentShaderReadSampledImage);
            pass.register_buffer_access(global_uniforms.id, graal::AccessType::AnyShaderReadUniformBuffer);

            // FIXME this needs to disappear
            for m in meshes.iter() {
                pass.register_buffer_access(m.vbo.id, graal::AccessType::VertexAttributeRead);
                pass.register_buffer_access(m.ibo.id, graal::AccessType::IndexRead);
            }

            pass.set_commands(move |context, cb| unsafe {
                // --- framebuffer ---
                let framebuffer = {
                    let target_view = context.create_image_view(&vk::ImageViewCreateInfo {
                        flags: Default::default(),
                        image: target.handle,
                        view_type: vk::ImageViewType::TYPE_2D,
                        format: target_format,
                        components: vk::ComponentMapping::default(),
                        subresource_range: vk::ImageSubresourceRange {
                            aspect_mask: vk::ImageAspectFlags::COLOR,
                            base_mip_level: 0,
                            level_count: 1,
                            base_array_layer: 0,
                            layer_count: 1,
                        },
                        ..Default::default()
                    });
                    let attachments = &[target_view];
                    context.create_framebuffer(
                        target_size.0,
                        target_size.1,
                        1,
                        render_pass,
                        attachments,
                    )
                };

                let clear_values = &[
                    vk::ClearValue {
                        color: vk::ClearColorValue {
                            float32: [0.05, 0.1, 0.15, 1.0],
                        },
                    },
                    vk::ClearValue {
                        color: vk::ClearColorValue {
                            float32: [0.0, 0.0, 0.0, 1.0],
                        },
                    },
                    vk::ClearValue {
                        color: vk::ClearColorValue {
                            float32: [0.0, 0.0, 0.0, 1.0],
                        },
                    },
                    vk::ClearValue {
                        depth_stencil: vk::ClearDepthStencilValue {
                            depth: 1.0,
                            stencil: 0,
                        },
                    },
                ];

                let render_pass_begin_info = vk::RenderPassBeginInfo {
                    render_pass,
                    framebuffer,
                    render_area: vk::Rect2D {
                        offset: vk::Offset2D { x: 0, y: 0 },
                        extent: vk::Extent2D {
                            width: target_size.0,
                            height: target_size.1,
                        },
                    },
                    clear_value_count: 4,
                    p_clear_values: clear_values.as_ptr(),
                    ..Default::default()
                };

                context.vulkan_device().cmd_begin_render_pass(
                    cb,
                    &render_pass_begin_info,
                    vk::SubpassContents::INLINE,
                );

                context.vulkan_device().cmd_set_viewport(
                    cb,
                    0,
                    &[vk::Viewport {
                        x: 0.0,
                        y: 0.0,
                        width: target_size.0 as f32,
                        height: target_size.1 as f32,
                        min_depth: 0.0,
                        max_depth: 1.0,
                    }],
                );
                context.vulkan_device().cmd_set_scissor(
                    cb,
                    0,
                    &[vk::Rect2D {
                        offset: Default::default(),
                        extent: vk::Extent2D {
                            width: target_size.0,
                            height: target_size.1,
                        },
                    }],
                );

                context.vulkan_device().cmd_bind_pipeline(
                    cb,
                    vk::PipelineBindPoint::GRAPHICS,
                    pipeline,
                );

                let image_view = context.create_image_view(&vk::ImageViewCreateInfo {
                    flags: Default::default(),
                    image: texture.handle,
                    view_type: vk::ImageViewType::TYPE_2D,
                    format: vk::Format::R8G8B8A8_SNORM,
                    components: vk::ComponentMapping::default(),
                    subresource_range: vk::ImageSubresourceRange {
                        aspect_mask: vk::ImageAspectFlags::COLOR,
                        base_mip_level: 0,
                        level_count: 1,
                        base_array_layer: 0,
                        layer_count: 1,
                    },
                    ..Default::default()
                });

                let globals_set = context.create_descriptor_set(&GlobalsInterface {
                    globals: global_uniforms.into(),
                    image: vk::DescriptorImageInfo {
                        sampler: vk::Sampler::null(),
                        image_view,
                        image_layout: vk::ImageLayout::SHADER_READ_ONLY_OPTIMAL,
                    },
                    sampler: vk::DescriptorImageInfo {
                        sampler,
                        image_view: Default::default(),
                        image_layout: Default::default(),
                    },
                });

                context.vulkan_device().cmd_bind_descriptor_sets(
                    cb,
                    vk::PipelineBindPoint::GRAPHICS,
                    pipeline_layout,
                    0,
                    &[globals_set],
                    &[],
                );

                for mesh in meshes.iter() {
                    context.vulkan_device().cmd_bind_vertex_buffers(
                        cb,
                        0,
                        &[mesh.vbo.handle],
                        &[0],
                    );

                    context.vulkan_device().cmd_bind_index_buffer(
                        cb,
                        mesh.ibo.handle,
                        0,
                        vk::IndexType::UINT32,
                    );

                    context
                        .vulkan_device()
                        .cmd_draw_indexed(cb, mesh.index_count, 1, 0, 0, 0);
                }

                context.vulkan_device().cmd_end_render_pass(cb);
            });
        });
    }
}
