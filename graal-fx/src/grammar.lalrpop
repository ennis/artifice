use crate::lexer::{Token, LexicalError};
use crate::{Variable, Module, Item, RenderPass, Expr, ParseError, UnaryOp,
     BinaryOp, VecExpr, Type, ParseState, Subpass, Attachment};
use crate::Arena;
use std::mem;

grammar<'ast, 'input, 'state>(text: &'input str, state: &'state mut ParseState<'ast>);

comma_separated<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

newline_separated<T>: Vec<T> = {
              <v:(<T> ",")*> <e:T?> => match e {
                  None => v,
                  Some(e) => {
                      let mut v = v;
                      v.push(e);
                      v
                  }
              }
          };




///////////////////////////////////////////////////////////////////////
// Module
///////////////////////////////////////////////////////////////////////
pub(crate) Module: Module<'ast> = {
    <items:Item*> => Module { items: state.arena.alloc_slice_copy(&items) }
};



///////////////////////////////////////////////////////////////////////
// Expressions
///////////////////////////////////////////////////////////////////////
BlockExpression: &'ast Expr<'ast> = {
    "{" <Expression> "}",
    IfElseExpression
};

IfElseExpression: &'ast Expr<'ast> = {
    "if" <condition:Expression> "{" <then_expr:Expression> "}" <else_expr:("else" <BlockExpression>)?> => state.arena.alloc(Expr::Conditional {
        condition,
        then_expr,
        else_expr,
    })
};

PrimaryExpression : &'ast Expr<'ast> = {
    IDENT           => state.arena.alloc(Expr::Variable(<>.copy_str(state.arena))),
    INT_LITERAL     => state.arena.alloc(Expr::IntLiteral(<>.as_i64())),
    FLOAT_LITERAL   => state.arena.alloc(Expr::FloatLiteral(<>.as_f64())),
    BOOL_LITERAL    => state.arena.alloc(Expr::BoolLiteral(<>.as_bool())),
    IfElseExpression,
    VecExpr,
    "(" <Expression> ")",
};

VecExpr: &'ast Expr<'ast> = {
    "u32x2" "(" <a:Expression> "," <b:Expression> ")" =>
       state.arena.alloc(Expr::VecExpr(VecExpr::U32x2(a,b))),
    "u32x3" "(" <a:Expression> "," <b:Expression> "," <c:Expression> ")" =>
       state.arena.alloc(Expr::VecExpr(VecExpr::U32x3(a,b,c))),
    "u32x4" "(" <a:Expression> "," <b:Expression> "," <c:Expression> "," <d:Expression> ")" =>
       state.arena.alloc(Expr::VecExpr(VecExpr::U32x4(a,b,c,d))),

    "i32x2" "(" <a:Expression> "," <b:Expression> ")" =>
       state.arena.alloc(Expr::VecExpr(VecExpr::I32x2(a,b))),
    "i32x3" "(" <a:Expression> "," <b:Expression> "," <c:Expression> ")" =>
       state.arena.alloc(Expr::VecExpr(VecExpr::I32x3(a,b,c))),
    "i32x4" "(" <a:Expression> "," <b:Expression> "," <c:Expression> "," <d:Expression> ")" =>
       state.arena.alloc(Expr::VecExpr(VecExpr::I32x4(a,b,c,d))),

    "f32x2" "(" <a:Expression> "," <b:Expression> ")" =>
       state.arena.alloc(Expr::VecExpr(VecExpr::F32x2(a,b))),
    "f32x3" "(" <a:Expression> "," <b:Expression> "," <c:Expression> ")" =>
       state.arena.alloc(Expr::VecExpr(VecExpr::F32x3(a,b,c))),
    "f32x4" "(" <a:Expression> "," <b:Expression> "," <c:Expression> "," <d:Expression> ")" =>
       state.arena.alloc(Expr::VecExpr(VecExpr::F32x4(a,b,c,d))),
};

UnaryExpression: &'ast Expr<'ast> = {
    PrimaryExpression,
    <o:UnaryOp> <e:UnaryExpression> => state.arena.alloc(Expr::Unary(o, e))
};

UnaryOp: UnaryOp = {
    "+"  => UnaryOp::Add,
    "-"  => UnaryOp::Minus,
    "!"  => UnaryOp::Not,
    "~"  => UnaryOp::Complement,
};

MultiplicativeExpression: &'ast Expr<'ast> = {
    UnaryExpression,
    <l:MultiplicativeExpression> "*" <r:UnaryExpression> => state.arena.alloc(Expr::Binary(BinaryOp::Mul, l, r)),
    <l:MultiplicativeExpression> "/" <r:UnaryExpression> => state.arena.alloc(Expr::Binary(BinaryOp::Div, l, r)),
    <l:MultiplicativeExpression> "%" <r:UnaryExpression> => state.arena.alloc(Expr::Binary(BinaryOp::Mod, l, r)),
};

AdditiveExpression: &'ast Expr<'ast> = {
    MultiplicativeExpression,
    <l:AdditiveExpression> "+" <r:MultiplicativeExpression> => state.arena.alloc(Expr::Binary(BinaryOp::Add, l, r)),
    <l:AdditiveExpression> "-" <r:MultiplicativeExpression> => state.arena.alloc(Expr::Binary(BinaryOp::Sub, l, r)),
};

ShiftExpression: &'ast Expr<'ast> = {
  AdditiveExpression,
  <l:ShiftExpression> ">>" <r:AdditiveExpression> => state.arena.alloc(Expr::Binary(BinaryOp::RShift, l, r)),
  <l:ShiftExpression> "<<" <r:AdditiveExpression> => state.arena.alloc(Expr::Binary(BinaryOp::LShift, l, r)),
};


AndExpression: &'ast Expr<'ast> = {
    ShiftExpression,
    <l:AndExpression> "&" <r:ShiftExpression> => state.arena.alloc(Expr::Binary(BinaryOp::And, l, r)),
};

XorExpression: &'ast Expr<'ast> = {
  AndExpression,
  <l:XorExpression> "^" <r:AndExpression> => state.arena.alloc(Expr::Binary(BinaryOp::Xor, l, r)),
};

OrExpression: &'ast Expr<'ast> = {
    XorExpression,
    <l:OrExpression> "|" <r:XorExpression> => state.arena.alloc(Expr::Binary(BinaryOp::Or, l, r)),
};

RelationalExpression: &'ast Expr<'ast> = {
    OrExpression,
    <l:RelationalExpression> "==" <r:OrExpression> => state.arena.alloc(Expr::Binary(BinaryOp::Eq, l, r)),
    <l:RelationalExpression> "!=" <r:OrExpression> => state.arena.alloc(Expr::Binary(BinaryOp::NEq, l, r)),
    <l:RelationalExpression> "<" <r:OrExpression> => state.arena.alloc(Expr::Binary(BinaryOp::Lt, l, r)),
    <l:RelationalExpression> ">" <r:OrExpression> => state.arena.alloc(Expr::Binary(BinaryOp::Gt, l, r)),
    <l:RelationalExpression> "<=" <r:OrExpression> => state.arena.alloc(Expr::Binary(BinaryOp::LEq, l, r)),
    <l:RelationalExpression> ">=" <r:OrExpression> => state.arena.alloc(Expr::Binary(BinaryOp::GEq, l, r)),
};

LogicalAndExpression: &'ast Expr<'ast> = {
    RelationalExpression,
    <l:LogicalAndExpression> "&&" <r:RelationalExpression> => state.arena.alloc(Expr::Binary(BinaryOp::LogicalAnd, l, r)),
};

LogicalOrExpression: &'ast Expr<'ast> = {
    LogicalAndExpression,
    <l:LogicalOrExpression> "||" <r:LogicalAndExpression> => state.arena.alloc(Expr::Binary(BinaryOp::LogicalOr, l, r)),
};

Expression: &'ast Expr<'ast> = { LogicalOrExpression };



///////////////////////////////////////////////////////////////////////
// Items
///////////////////////////////////////////////////////////////////////
Item: Item<'ast> = {
    <var:Variable> => Item::Variable(var),
    <renderpass:RenderPass> => Item::RenderPass(renderpass)
};



///////////////////////////////////////////////////////////////////////
// Render passes
///////////////////////////////////////////////////////////////////////
RenderPass : RenderPass<'ast> = {
    "RenderPass" <name:IDENT> "{"
    <attachments:RenderPassAttachment*>
    <subpasses:RenderPassSubpass*>
    "}"
     =>
    {
        let attachments = state.arena.alloc_slice_copy(&attachments);
        let subpasses = state.arena.alloc_slice_copy(&subpasses);
        RenderPass {
            name: name.copy_str(state.arena),
            attachments,
            subpasses
        }
    }
};

RenderPassAttachment : Attachment<'ast> = {
    // build in place
    "Attachment" <name:IDENT> "{" RenderPassAttachmentProperty* "}" => {
        state.cur_attachment.name = name.copy_str(state.arena);
        mem::take(&mut state.cur_attachment)
    }
}

RenderPassAttachmentProperty : () = {
    <prop:IDENT> "=" <value:Expression> ";" =>
    {
        match prop.as_str() {
            "flags" => state.cur_attachment.flags = Some(value),
            "format" => state.cur_attachment.format = Some(value),
            "samples" => state.cur_attachment.samples = Some(value),
            "loadOp" => state.cur_attachment.load_op = Some(value),
            "storeOp" => state.cur_attachment.store_op = Some(value),
            "stencilLoadOp" => state.cur_attachment.stencil_load_op = Some(value),
            "stencilStoreOp" => state.cur_attachment.stencil_store_op = Some(value),
            "initialLayout" => state.cur_attachment.initial_layout = Some(value),
            "finalLayout" => state.cur_attachment.final_layout = Some(value),
            _ => {},
        }
    }
};

RenderPassSubpass : Subpass<'ast> = {
    "Subpass" <name:IDENT> "{" "}" => Subpass::default()
};

///////////////////////////////////////////////////////////////////////
// Variables
///////////////////////////////////////////////////////////////////////
Variable: Variable<'ast> = {
    <v:Visibility?> <name:IDENT> ":" <ty:Type> <initializer:("=" <Expression>)?> ";" =>
       Variable {
           name: name.copy_str(state.arena),
           ty,
           initializer,
       }
};

Visibility = {
    "pub"
};

///////////////////////////////////////////////////////////////////////
// Types
///////////////////////////////////////////////////////////////////////
Type : Type = {
    "u32x2" => Type::U32x2,
    "u32x3" => Type::U32x3,
    "u32x4" => Type::U32x4,
    "i32x2" => Type::I32x2,
    "i32x3" => Type::I32x3,
    "i32x4" => Type::I32x4,
    "f32x2" => Type::F32x2,
    "f32x3" => Type::F32x3,
    "f32x4" => Type::F32x4,
};

extern {
    type Location = usize;
    type Error = ParseError;

    enum Token<'input> {
        STRING => Token::String(_),
        IDENT => Token::Ident(_),
        BOOL_LITERAL => Token::BoolLiteral(_),
        INT_LITERAL => Token::IntLiteral(_),
        FLOAT_LITERAL => Token::FloatLiteral(_),

        "(" => Token::LParen,
        ")" => Token::RParen,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        "." => Token::Dot,
        "++" => Token::Inc,
        "--" => Token::Dec,
        "+" => Token::Plus,
        "-" => Token::Dash,
        "!" => Token::Bang,
        "~" => Token::Tilde,
        "*" => Token::Star,
        "/" => Token::Slash,
        "%" => Token::Percent,
        "<<" => Token::LShift,
        ">>" => Token::RShift,
        "<" => Token::LAngle,
        ">" => Token::RAngle,
        "<=" => Token::LEqual,
        ">=" => Token::REqual,
        "==" => Token::DEqual,
        "!=" => Token::BangEqual,
        "&" => Token::Ampersand,
        "^" => Token::Caret,
        "|" => Token::Bar,
        "&&" => Token::And,
        "^^" => Token::Xor,
        "||" => Token::Or,
        "?" => Token::Question,
        ":" => Token::Colon,
        "=" => Token::Equal,
        "*=" => Token::StarEqual,
        "/=" => Token::SlashEqual,
        "%=" => Token::PercentEqual,
        "+=" => Token::PlusEqual,
        "-=" => Token::DashEqual,
        "<<=" => Token::LShiftEqual,
        ">>=" => Token::RShiftEqual,
        "&=" => Token::AmpersandEqual,
        "^=" => Token::CaretEqual,
        "|=" => Token::BarEqual,
        "," => Token::Comma,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        ";" => Token::Semicolon,

        "pub" => Token::Pub,
        "const" => Token::Const,
        "if" => Token::If,
        "else" => Token::Else,

        "Attachment" => Token::Attachment,
        "RenderPass" => Token::RenderPass,
        "Subpass" => Token::Subpass,

        "u32x2" => Token::U32x2,
        "u32x3" => Token::U32x3,
        "u32x4" => Token::U32x4,
        "i32x2" => Token::I32x2,
        "i32x3" => Token::I32x3,
        "i32x4" => Token::I32x4,
        "f32x2" => Token::F32x2,
        "f32x3" => Token::F32x3,
        "f32x4" => Token::F32x4,
    }
}